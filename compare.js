// https://github.com/OpenMS/OpenMS/blob/5a70018d9e03ce32e64fcbb1c985b7a1256efc7a/src/tests/class_tests/openms/data/PILISSequenceDB_DFPIANGER_1.dta
spectrum = [{"mz":1019.74, "intensity": 1},
	{"mz":326.1, "intensity": 122095.0},
//	{"mz":339.9, "intensity": 111771.0},
	{"mz":326.1, "intensity": 111771.0},
	{"mz":351.1, "intensity": 60817.0},
	{"mz":354.1, "intensity": 94638.0},
	{"mz":358.3, "intensity": 69098.0},
	{"mz":361.3, "intensity": 96982.0},
	{"mz":368.0, "intensity": 80302.0},
	{"mz":382.3, "intensity": 50097.0},
	{"mz":395.9, "intensity": 92585.0},
	{"mz":414.5, "intensity": 53422.0},
	{"mz":419.8, "intensity": 31275.0},
	{"mz":436.2, "intensity": 72376.0},
	{"mz":440.3, "intensity": 105213.0},
	{"mz":442.3, "intensity": 65712.0},
	{"mz":447.4, "intensity": 50161.0},
	{"mz":453.1, "intensity": 45756.0},
	{"mz":457.0, "intensity": 35569.0},
	{"mz":458.4, "intensity": 301294.0},
	{"mz":459.2, "intensity": 55526.0},
	{"mz":465.2, "intensity": 66318.0},
	{"mz":467.1, "intensity": 139167.0},
	{"mz":473.3, "intensity": 110864.0},
	{"mz":475.5, "intensity": 172539.0},
	{"mz":477.3, "intensity": 27454.0},
	{"mz":486.2, "intensity": 43478.0},
	{"mz":491.7, "intensity": 19983.0},
	{"mz":493.5, "intensity": 73178.0},
	{"mz":494.1, "intensity": 56540.0},
	{"mz":499.0, "intensity": 64971.0},
	{"mz":506.1, "intensity": 45588.0},
	{"mz":510.2, "intensity": 54341.0},
	{"mz":512.0, "intensity": 76225.0},
	{"mz":515.1, "intensity": 27438.0},
	{"mz":520.4, "intensity": 53385.0},
	{"mz":522.2, "intensity": 51700.0},
	{"mz":529.4, "intensity": 60836.0},
	{"mz":531.0, "intensity": 24524.0},
	{"mz":540.1, "intensity": 44815.0},
	{"mz":544.1, "intensity": 43420.0},
	{"mz":546.4, "intensity": 215804.0},
	{"mz":548.2, "intensity": 51372.0},
	{"mz":554.0, "intensity": 143092.0},
	{"mz":555.2, "intensity": 60423.0},
	{"mz":556.5, "intensity": 38914.0},
	{"mz":557.3, "intensity": 81474.0},
	{"mz":564.2, "intensity": 173913.0},
	{"mz":564.3, "intensity": 79074.0},
	{"mz":565.4, "intensity": 88793.0},
	{"mz":566.3, "intensity": 147328.0},
	{"mz":567.1, "intensity": 30076.0},
	{"mz":582.1, "intensity": 125159.0},
	{"mz":582.7, "intensity": 109298.0},
	{"mz":583.4, "intensity": 38742.0},
	{"mz":599.1, "intensity": 63273.0},
	{"mz":605.5, "intensity": 41375.0},
	{"mz":613.2, "intensity": 73690.0},
	{"mz":617.5, "intensity": 45434.0},
	{"mz":623.1, "intensity": 35836.0},
	{"mz":625.9, "intensity": 56543.0},
	{"mz":634.4, "intensity": 74273.0},
	{"mz":642.2, "intensity": 77360.0},
	{"mz":646.3, "intensity": 58459.0},
	{"mz":659.2, "intensity": 76760.0},
	{"mz":661.9, "intensity": 47952.0},
	{"mz":679.9, "intensity": 67439.0},
	{"mz":684.9, "intensity": 85950.0},
	{"mz":688.5, "intensity": 79347.0},
	{"mz":694.2, "intensity": 50504.0},
	{"mz":696.4, "intensity": 367308.0},
	{"mz":697.6, "intensity": 111032.0},
	{"mz":705.5, "intensity": 104236.0},
	{"mz":712.2, "intensity": 58222.0},
	{"mz":714.2, "intensity": 73175.0},
	{"mz":722.5, "intensity": 232657.0},
	{"mz":729.9, "intensity": 135740.0},
	{"mz":739.3, "intensity": 326151.0},
	{"mz":746.5, "intensity": 66717.0},
	{"mz":756.5, "intensity": 981763.0},
	{"mz":757.5, "intensity": 410536.0},
	{"mz":758.5, "intensity": 23965.0},
	{"mz":763.0, "intensity": 46178.0},
	{"mz":775.3, "intensity": 30680.0},
	{"mz":781.6, "intensity": 69481.0},
	{"mz":794.6, "intensity": 68750.0},
	{"mz":799.4, "intensity": 88883.0},
	{"mz":814.2, "intensity": 39893.0},
	{"mz":819.7, "intensity": 25447.0},
	{"mz":823.3, "intensity": 47790.0},
	{"mz":826.0, "intensity": 28343.0},
	{"mz":827.3, "intensity": 116169.0},
	{"mz":834.3, "intensity": 39037.0},
	{"mz":843.5, "intensity": 112391.0},
	{"mz":844.6, "intensity": 136926.0},
	{"mz":858.7, "intensity": 79794.0},
	{"mz":862.6, "intensity": 29511.0},
	{"mz":867.5, "intensity": 31673.0},
	{"mz":869.3, "intensity": 35571.0},
	{"mz":872.2, "intensity": 63264.0},
	{"mz":879.7, "intensity": 55058.0},
	{"mz":885.8, "intensity": 1078052.0},
	{"mz":887.5, "intensity": 495926.0},
	{"mz":895.5, "intensity": 83799.0},
	{"mz":902.7, "intensity": 95492.0},
	{"mz":902.8, "intensity": 206175.0},
	{"mz":903.5, "intensity": 30389248.0},
	{"mz":903.6, "intensity": 28900096.0},
	{"mz":904.5, "intensity": 11919616.0},
	{"mz":904.6, "intensity": 10542080.0},
	{"mz":905.5, "intensity": 4662656.0},
	{"mz":915.3, "intensity": 46839.0},
	{"mz":954.6, "intensity": 55270.0},
	{"mz":956.0, "intensity": 45890.0},
	{"mz":956.8, "intensity": 96771.0},
	{"mz":957.2, "intensity": 196543.0},
	{"mz":958.3, "intensity": 34320.0},
	{"mz":958.4, "intensity": 67905.0},
	{"mz":960.0, "intensity": 88021.0},
	{"mz":960.7, "intensity": 139949.0},
	{"mz":964.9, "intensity": 81616.0},
	{"mz":967.2, "intensity": 38213.0},
	{"mz":973.2, "intensity": 36065.0},
	{"mz":974.4, "intensity": 34597.0},
	{"mz":975.8, "intensity": 264639.0},
	{"mz":976.6, "intensity": 51444.0},
	{"mz":977.4, "intensity": 132478.0},
	{"mz":983.7, "intensity": 49895.0},
	{"mz":984.4, "intensity": 501645.0}]

// bin distiance of openMS
// we expect already binned data (meaning summed intensity for same m/z bin)
spectrum_1 = spectrum
//spectrum_1 = spectrum_1.filter((x, i) => i < 10)
//spectrum_2 =spectrum.copy()
spectrum_2= Object.assign([], spectrum_1); 

x = spectrum_2.pop()
//spectrum_2 = spectrum_2.filter((x, i) => i < 10)
//spectrum_2.push({"mz": 1002, "intensity": 1})


extract_mz = function(prev, next){
	// maps [{"mz":v1, "intensity": v2}, ...]
	// to {"v1" : v2, ....}
	prev[next["mz"]] = next["intensity"]
	return(prev)
}

spectrum_1_simple = spectrum_1.reduce(extract_mz, {})
spectrum_2_simple = spectrum_2.reduce(extract_mz, {})

//let spectra_zipped = arr1.map((x, i) => [x, arr2[i]]);


mz_value1 = spectrum_1.map(x => x["mz"])
mz_value2 = spectrum_2.map(x => x["mz"])
mz_set = [...new Set(mz_value1.concat(mz_value2))]

z = function(intensity_bin){
	return {"intensity_1": intensity_bin in spectrum_1_simple?spectrum_1_simple[intensity_bin]:0,
		"intensity_2": intensity_bin in spectrum_2_simple?spectrum_2_simple[intensity_bin]:0}

}
aligned_spectrum = mz_set.map(z)

// sqr root of the product of sums of intensity
denominator_f = function(prev, next){
	prev["sum_1"] += next["intensity_1"]
	prev["sum_2"] += next["intensity_2"]
	return(prev)

}

//obj =  {"sum_1": 0, "sum_2": 0}

f2 = function(obj){
	obj["1_m_1"] = obj["intensity_1"] * obj["intensity_1"]
	obj["2_m_2"] = obj["intensity_2"] * obj["intensity_2"]
	obj["1_m_2"] = obj["intensity_1"] * obj["intensity_2"]
	return(obj)
}

reducer = function(prev, next){
	prev["sum_1_m_1"] += next["1_m_1"]
	prev["sum_2_m_2"] += next["2_m_2"]
	prev["sum_1_m_2"] += next["1_m_2"]
	return(prev)

}
// BE AWARE reduce will do it by pointer if you would provide a template as variable
// start = {"sum_1_m_1" : 0, "sum_2_m_2": 0, "sum_1_m_2" : 0}
necessary_dot = aligned_spectrum.map(f2 ).reduce(reducer,{"sum_1_m_1" : 0, "sum_2_m_2": 0, "sum_1_m_2" : 0}
)
console.log(necessary_dot["sum_1_m_2"] / Math.sqrt(necessary_dot["sum_1_m_1"] * necessary_dot["sum_2_m_2"] ))
//console.log(aligned_spectrum.reduce(f2, {}))



// if you have two unit vectors, the dot product is the cosine of the angle between them

///////////////////////////////////////////////////////////////////////////////////////////

// TODO
// calculate binning
// sum up
//

spectrum = [{"mz":1019.74, "intensity": 1},
	{"mz":326.1234, "intensity": 122095.0},
	{"mz":326.1345, "intensity": 111771.0},
	{"mz":326.1232, "intensity": 60817.0}]



f_rounding = function(digits){
	return function(mz){
		return(Math.round(Math.pow(10, digits) * mz) / Math.pow(10, digits))
	}
}

f_rounding_2 = f_rounding(2)
f_rounding_3 = f_rounding(3)


add_rounding = function(obj){
	obj["mz_round"] = f_rounding_3(obj["mz"])
	return(obj)
}

// EXAMPLE BINNED SPECTRA
//
var groupBy = function(data, key) { // `data` is an array of objects, `key` is the key (or property accessor) to group by
	// reduce runs this anonymous function on each element of `data` (the `item` parameter,
	//   // returning the `storage` parameter at the end
	return data.reduce(function(storage, item) {
		//         // get the first instance of the key by which we're grouping
		var group = item[key];
		//                 
		//                     // set `storage` for this instance of group to the outer scope (if not empty) or initialize it
		storage[group] = storage[group] || [];
		//                             
		//                                 // add this item to its group within `storage`
		storage[group].push(item);
		//                                         
		//                                             // return the updated storage to the reduce function, which will then loop through the next 
		return storage; 
	}, {}); // {} is the initial value of the storage
};


grouped_spectrum = groupBy(spectrum.map(add_rounding), "mz_round")

test =   [ { "mz": 326.1234, "intensity": 122095, "mz_round": 326.123 },
	{ "mz": 326.1232, "intensity": 60817, "mz_round": 326.123 } ] 

sum_group = function(prev, next){
	prev["intensity"] += next["intensity"]
	return(prev)

}

//console.log(test.reduce(sum_group, container_summing))

grouping_f = function(list_o){
	/// [ '326.123',
	//  [ { mz: 326.1234, intensity: 122095, mz_round: 326.123 },
	//      { mz: 326.1232, intensity: 60817, mz_round: 326.123 } ] ]
	//
	o_peak = list_o[1].reduce(sum_group, {"intensity": 0})
	o_peak["mz"] = parseFloat(list_o[0])
	return(o_peak)
}
s = Object.entries(grouped_spectrum).map(grouping_f)
// second element of ever elment is the list of objects. first element just the grouping key


var ipsa_helper = {
	"binning" :
	f = function(spectrum){
		grouped_spectrum = groupBy(spectrum.map(add_rounding), "mz_round")
		s = Object.entries(grouped_spectrum).map(grouping_f)
		return(s)
	},
	"comparison":{
		"dot_product": function(spectrum_1, spectrum_2){
			spectrum_1_simple = spectrum_1.reduce(extract_mz, {})
			spectrum_2_simple = spectrum_2.reduce(extract_mz, {})
			mz_value1 = spectrum_1.map(x => x["mz"])
			mz_value2 = spectrum_2.map(x => x["mz"])
			mz_set = [...new Set(mz_value1.concat(mz_value2))]
			aligned_spectrum = mz_set.map(z)
			necessary_dot = aligned_spectrum.map(f2 ).reduce(reducer,{"sum_1_m_1" : 0, "sum_2_m_2": 0, "sum_1_m_2" : 0}
			)
			similarity = necessary_dot["sum_1_m_2"] / Math.sqrt(necessary_dot["sum_1_m_1"] * necessary_dot["sum_2_m_2"] )

			return(similarity)

		}
	}

}
a = ipsa_helper["binning"](spectrum_1)
console.log(a.length)
// console.log(ipsa_helper["binning"](spectrum_1))
console.log(ipsa_helper["comparison"]["dot_product"](spectrum_1, spectrum_2))
